// src/lib/xp.ts
import { prisma } from "./prisma";
import { withMeta } from "./prisma-safe";

const BADGES = {
  "premier_pas": { name: "Premier pas", description: "Premier exercice terminé." },
  "streak_3": { name: "Assidu 3", description: "3 jours d'étude consécutifs." },
  "streak_7": { name: "Assidu 7", description: "7 jours d'étude consécutifs." },
} as const;

function dateUTC(date = new Date()) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
}
function daysBetweenUTC(a: Date, b: Date) {
  const ms = dateUTC(a).getTime() - dateUTC(b).getTime();
  return Math.round(ms / (24*3600*1000));
}

export async function ensureStreak(userId: string) {
  let s = await prisma.userStreak.findUnique({ where: { userId } });
  if (!s) {
    s = await pri############################################
# 2)current: 0, best: 0, lastDate: dateUTC() }) });
  }
  return s;
}

export async function awardBadge(userId: string, slug: keyof typeof BADGES) {
  try {
    await prisma.userBadge.create({ data: withMeta({ userId, slug }) });
  } catch { /* unique constraint -> déjà attribué */ }
}

export async function hasBadge(userId: string, slug: keyof typeof BADGES) {
  const b = await prisma.userBadge.findFirst({ where: { userId, slug } });
  return Boolean(b);
}

export async function registerActivity(userId: string, type: string) {
  // Log activité
  await prisma.userActivity.create({ data: withMeta({ userId, type }) });

  // Streak
  let st = await ensureStreak(userId);
  const today = dateUTC();
  const delta = daysBetweenUTC(today, st.lastDate);

  if (delta === 0) {
    // même jour: pas d'incrément
  } else if (delta === 1) {
    st = await prisma.userStreak.update({
      where: { userId },
      data: { current: st.current + 1, best: Math.max(st.best, st.current + 1), lastDate: today }
    });
  } else {
    // trou (>1j): reset à 1
    st = await prisma.userStreak.update({
      where: { userId },
      data: { current: 1, best: Math.max(st.best, 1), lastDate: today }
    });
  }

  // Badges
  if (type === "exercise_completed" && !(await hasBadge(userId, "premier_pas"))) {
    await awardBadge(userId, "premier_pas");
  }
  if (st.current >= 3) await awardBadge(userId, "streak_3");
  if (st.current >= 7) await awardBadge(userId, "streak_7");

  return st;
}

export async function getXPSummary(userId: string) {
  const s = await ensureStreak(userId);
  const badges = await prisma.userBadge.findMany({ where: { userId }, orderBy: { awardedAt: "asc" } });
  return {
    streak: { current: s.current, best: s.best, lastDate: s.lastDate },
    badges: badges.map(b => ({ slug: b.slug, name: BADGES[b.slug as keyof typeof BADGES]?.name ?? b.slug }))
  };
}
