import { NextResponse } from 'next/server'
import Stripe from 'stripe'
import prisma from '@/lib/prisma'
import { awardOnSubscription } from '@/lib/badges/award'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

const stripeKey = process.env.STRIPE_SECRET_KEY || ''
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET || ''

async function upsertFromSession(session: Stripe.Checkout.Session) {
  const userId = (session.client_reference_id as string) || ''
  if (!userId) return

  const type = (session.metadata?.type as string) || ''
  const key = (session.metadata?.key as string) || ''
  const plan = (session.metadata?.plan as string) || ''

  const subId =
    typeof session.subscription === 'string'
      ? session.subscription
      : (session.subscription as any)?.id
  const priceId =
    session.line_items?.data?.[0]?.price?.id ||
    (session.metadata as any)?.priceId ||
    ''

  // Récupérer la subscription Stripe pour dates/état
  const stripe = new Stripe(stripeKey)
  const sub = subId ? await stripe.subscriptions.retrieve(subId) : null

  const rec = await prisma.userSubscription.upsert({
    where: { stripeSubId: subId || 'no-sub' },
    update: {
      status: sub?.status || 'active',
      stripeCustomerId: sub?.customer as string,
      stripePriceId: priceId || sub?.items?.data?.[0]?.price?.id || undefined,
      currentPeriodEnd: sub?.current_period_end
        ? new Date(sub.current_period_end * 1000)
        : undefined,
      cancelAtPeriodEnd: sub?.cancel_at_period_end ?? false,
      type,
      key,
      plan,
    },
    create: {
      userId,
      type,
      key,
      plan,
      status: sub?.status || 'active',
      stripeSubId: subId || undefined,
      stripeCustomerId: sub?.customer as string,
      stripePriceId: priceId || sub?.items?.data?.[0]?.price?.id || undefined,
      currentPeriodEnd: sub?.current_period_end
        ? new Date(sub.current_period_end * 1000)
        : undefined,
      cancelAtPeriodEnd: sub?.cancel_at_period_end ?? false,
    },
  })

  // Badges éventuels selon achat
  try {
    if (type === 'pack' && key === 'pack3')
      await awardOnSubscription(userId, 'pack3')
    if (type === 'pack' && key === 'family')
      await awardOnSubscription(userId, 'family')
    if (type === 'subject') await awardOnSubscription(userId, 'sub_first')
  } catch {}
}

async function updateFromStripeSub(sub: Stripe.Subscription) {
  // On effectue le meilleur effort: retrouver l'entry par stripeSubId
  const rec = await prisma.userSubscription.findUnique({
    where: { stripeSubId: sub.id },
  })
  if (!rec) return
  await prisma.userSubscription.update({
    where: { stripeSubId: sub.id },
    data: {
      status: sub.status,
      stripeCustomerId: sub.customer as string,
      stripePriceId: sub.items?.data?.[0]?.price?.id,
      currentPeriodEnd: sub.current_period_end
        ? new Date(sub.current_period_end * 1000)
        : undefined,
      cancelAtPeriodEnd: sub.cancel_at_period_end ?? false,
    },
  })
}

export async function POST(req: Request) {
  if (!stripeKey || !webhookSecret) {
    return NextResponse.json({ error: 'Stripe non configuré' }, { status: 501 })
  }
  const sig = req.headers.get('stripe-signature') || ''
  const raw = await req.text()
  const stripe = new Stripe(stripeKey)

  let event: Stripe.Event
  try {
    event = stripe.webhooks.constructEvent(raw, sig, webhookSecret)
  } catch (e: any) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
  }

  try {
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session
        await upsertFromSession(session)
        break
      }
      case 'customer.subscription.updated':
      case 'customer.subscription.deleted':
      case 'customer.subscription.created': {
        const sub = event.data.object as Stripe.Subscription
        await updateFromStripeSub(sub)
        break
      }
      default:
        break
    }
  } catch (e) {
    console.error('[stripe webhook] handler error', e)
    return NextResponse.json({ received: true, handled: false })
  }

  return NextResponse.json({ received: true })
}

export async function GET() {
  return NextResponse.json({ ok: true, hint: 'POST Stripe events here' })
}
